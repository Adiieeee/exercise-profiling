# Module 5

- SS all-student JMeter
  ![Screenshot 2025-03-14 195652](https://github.com/user-attachments/assets/a38c6631-d3da-448c-a86f-bf3b8d7f944c)

- SS all-student-name JMeter
  ![Screenshot 2025-03-14 195904](https://github.com/user-attachments/assets/6e9421b9-5f5f-47b7-903e-14131d565ec2)

- SS highest-gpa JMeter
  ![Screenshot 2025-03-14 201905](https://github.com/user-attachments/assets/76184c4a-368d-4ad9-9dfb-80dad9c6d4f5)

- SS testresults1
  ![Screenshot 2025-03-14 202040](https://github.com/user-attachments/assets/e9487348-feeb-4b1d-81c5-e0b7a326382d)

- SS testresults2
  ![Screenshot 2025-03-14 202047](https://github.com/user-attachments/assets/08dc43c5-2177-4217-a980-488e507a7b59)

- SS testresults3
  ![Screenshot 2025-03-14 202056](https://github.com/user-attachments/assets/0e12e07e-ffc5-4eb8-8cb3-67e66e30cced)

### 1. What is the difference between the approach of performance testing with JMeter and profiling with IntelliJ Profiler in the context of optimizing application performance?
JMeter dan IntelliJ Profiler adalah dua alat yang memiliki peran berbeda namun saling melengkapi dalam mengoptimalkan performa aplikasi. JMeter digunakan untuk melakukan pengujian performa secara keseluruhan, seperti menguji bagaimana aplikasi menangani banyak pengguna atau permintaan secara bersamaan. Alat ini mensimulasikan beban tinggi pada aplikasi dan memberikan laporan tentang waktu respons, throughput, atau error yang terjadi. Tujuannya adalah memastikan aplikasi dapat bekerja dengan baik di bawah tekanan beban yang besar.

Di sisi lain, IntelliJ Profiler lebih fokus pada analisis kode program secara detail. Alat ini membantu developer menemukan bagian kode yang lambat, boros memori, atau tidak efisien. Dengan memberikan informasi seperti waktu eksekusi metode, penggunaan CPU, atau kebocoran memori, IntelliJ Profiler memungkinkan developer untuk memperbaiki kode agar lebih optimal.

Keduanya saling melengkapi: JMeter membantu menemukan **di mana** masalah performa terjadi, misalnya pada API tertentu atau database, sementara IntelliJ Profiler membantu menemukan **mengapa** masalah itu terjadi, seperti kode yang tidak efisien atau kebocoran memori. Dengan menggunakan kedua alat ini, developer dapat mengoptimalkan aplikasi dari sisi sistem maupun kode, sehingga aplikasi tidak hanya mampu menangani beban tinggi tetapi juga berjalan dengan efisien.

### 2. How does the profiling process help you in identifying and understanding the weak points in your application?
Proses profiling membantu mengidentifikasi dan memahami titik lemah dalam aplikasi dengan memberikan wawasan mendetail tentang perilaku aplikasi selama runtime, seperti penggunaan CPU, alokasi memori, waktu eksekusi metode, dan aktivitas thread. Dengan data ini, developer dapat melihat bagian kode yang memakan waktu terlalu lama, menggunakan memori berlebihan, atau menyebabkan kebocoran memori. Misalnya, jika suatu metode menjadi hotspot karena eksekusinya lambat, profiler akan menunjukkannya, sehingga developer tahu area tersebut perlu dioptimalkan. Profiling juga membantu menemukan masalah seperti thread yang terblokir atau garbage collection yang terlalu sering, yang dapat memengaruhi performa aplikasi. Dengan memahami titik lemah ini, developer dapat melakukan perbaikan yang tepat, seperti mengoptimalkan algoritma, mengurangi alokasi memori, atau memperbaiki manajemen thread, sehingga aplikasi menjadi lebih efisien dan mampu menangani beban tinggi dengan baik.

### 3. Do you think IntelliJ Profiler is effective in assisting you to analyze and identify bottlenecks in your application code?
Ya, **IntelliJ Profiler** sangat efektif dalam membantu developer menganalisis dan mengidentifikasi bottleneck dalam kode aplikasi. Alat ini memberikan wawasan mendetail tentang perilaku aplikasi saat dijalankan, seperti penggunaan CPU, alokasi memori, aktivitas garbage collection, dan waktu eksekusi metode. Dengan fitur seperti **flame graph**, **call tree**, dan **memory snapshot**, developer dapat menemukan bagian kode yang menyebabkan masalah performa, seperti metode yang lambat atau penggunaan memori berlebihan. Misalnya, jika suatu metode memakan waktu eksekusi terlalu lama, IntelliJ Profiler akan menandainya sebagai hotspot, sehingga developer tahu area tersebut perlu dioptimalkan. Selain itu, alat ini juga dapat mendeteksi kebocoran memori atau pembuatan objek yang tidak efisien, yang sering menjadi penyebab menurunnya performa. Karena terintegrasi langsung dengan IntelliJ IDEA, profiling dapat dilakukan dengan mudah selama proses pengembangan atau debugging. Secara keseluruhan, IntelliJ Profiler adalah alat yang sangat berguna untuk mengidentifikasi dan memperbaiki bottleneck di level kode, meskipun akan lebih efektif jika digunakan bersama alat lain seperti **JMeter** untuk pengujian performa di level sistem, karena keduanya saling melengkapi dalam memberikan gambaran lengkap tentang performa aplikasi.

### 4. What are the main challenges you face when conducting performance testing and profiling, and how do you overcome these challenges?
Salah satu tantangan utama dalam melakukan performance testing dan profiling adalah mengidentifikasi dan mereplikasi skenario beban yang realistis, karena aplikasi sering kali digunakan dalam kondisi yang bervariasi dan sulit diprediksi. Untuk mengatasinya, penting untuk menganalisis pola penggunaan aplikasi di lingkungan produksi dan membuat skenario pengujian yang mendekati kondisi nyata. Selain itu, mengumpulkan dan menganalisis data yang akurat juga bisa menjadi tantangan, terutama ketika aplikasi memiliki banyak komponen yang saling berinteraksi. Untuk mengatasi ini, penggunaan alat seperti **JMeter** untuk performance testing dan **IntelliJ Profiler** untuk profiling dapat membantu, karena keduanya menyediakan data yang rinci dan terstruktur. Tantangan lain adalah memastikan bahwa lingkungan pengujian mirip dengan lingkungan produksi, karena perbedaan infrastruktur dapat memengaruhi hasil pengujian. Solusinya adalah dengan menggunakan lingkungan staging yang meniru produksi sebisa mungkin. Terakhir, interpretasi hasil yang kompleks dari profiling dan pengujian bisa membingungkan, tetapi dengan mempelajari alat secara mendalam dan berkolaborasi dengan tim, developer dapat mengambil keputusan yang tepat untuk mengoptimalkan performa aplikasi.

### 5. What are the main benefits you gain from using IntelliJ Profiler for profiling your application code?
Manfaat utama menggunakan **IntelliJ Profiler** untuk profiling kode aplikasi adalah kemampuannya memberikan wawasan mendetail tentang kinerja aplikasi di level kode, seperti waktu eksekusi metode, penggunaan CPU, alokasi memori, dan aktivitas thread. Dengan fitur seperti **flame graph** dan **call tree**, developer dapat dengan mudah mengidentifikasi metode atau bagian kode yang menjadi bottleneck, seperti kode yang lambat atau boros memori. Selain itu, IntelliJ Profiler juga membantu mendeteksi masalah seperti kebocoran memori atau garbage collection yang tidak efisien, yang dapat memengaruhi performa aplikasi. Alat ini terintegrasi langsung dengan IntelliJ IDEA, sehingga developer dapat melakukan profiling sambil mengembangkan atau debugging kode, membuat proses optimasi lebih efisien. Dengan memahami dan memperbaiki titik lemah ini, aplikasi dapat berjalan lebih cepat, menggunakan sumber daya lebih efisien, dan memberikan pengalaman pengguna yang lebih baik.

### 6. How do you handle situations where the results from profiling with IntelliJ Profiler are not entirely consistent with findings from performance testing using JMeter?
Ketika hasil profiling dengan **IntelliJ Profiler** tidak sepenuhnya konsisten dengan temuan dari performance testing menggunakan **JMeter**, langkah pertama yang perlu dilakukan adalah memverifikasi lingkungan pengujian dan profiling untuk memastikan keduanya mirip dengan kondisi produksi. Perbedaan infrastruktur atau konfigurasi dapat menyebabkan ketidaksesuaian hasil. Selanjutnya, penting untuk memeriksa apakah skenario pengujian di JMeter benar-benar mencerminkan penggunaan aplikasi yang sebenarnya, karena beban yang tidak realistis dapat menghasilkan temuan yang menyesatkan. Jika hasil tetap tidak konsisten, developer dapat menggunakan kedua alat secara bersamaan: JMeter untuk mengidentifikasi di mana masalah performa terjadi (misalnya, API lambat atau database bermasalah), sementara IntelliJ Profiler digunakan untuk menganalisis mengapa masalah itu terjadi (misalnya, kode yang tidak efisien atau kebocoran memori). Kolaborasi antara tim pengembang dan QA juga penting untuk memastikan bahwa data dari kedua alat dianalisis secara holistik, sehingga solusi yang diambil dapat mengatasi masalah dari kedua perspektif, baik sistem maupun kode. Dengan pendekatan ini, ketidaksesuaian hasil dapat diatasi dan optimasi performa aplikasi menjadi lebih efektif.

### 7. What strategies do you implement in optimizing application code after analyzing results from performance testing and profiling? How do you ensure the changes you make do not affect the application's functionality?
Setelah menganalisis hasil dari performance testing dan profiling, strategi yang dapat diimplementasikan untuk mengoptimalkan kode aplikasi meliputi beberapa langkah kunci. Pertama, fokus pada bagian kode yang diidentifikasi sebagai bottleneck, seperti metode yang lambat atau penggunaan memori berlebihan, dengan mengoptimalkan algoritma, mengurangi kompleksitas waktu, atau meminimalkan alokasi objek yang tidak perlu. Kedua, perbaiki masalah seperti kebocoran memori dengan memastikan objek yang tidak terpakai dibersihkan dengan benar atau menggunakan teknik caching yang lebih efisien. Ketiga, optimalkan query database dan panggilan API dengan mengurangi jumlah permintaan atau menggunakan indeks yang tepat. 

Untuk memastikan perubahan yang dilakukan tidak memengaruhi fungsionalitas aplikasi, penting untuk menjalankan **unit testing** dan **integration testing** setelah setiap perubahan kode. Selain itu, lakukan **regression testing** untuk memverifikasi bahwa fitur yang ada tetap berfungsi seperti sebelumnya. Penggunaan **Continuous Integration (CI)** dan **Continuous Deployment (CD)** juga dapat membantu mengotomatisasi proses pengujian dan memastikan bahwa perubahan kode tidak menyebabkan masalah baru. Terakhir, kolaborasi antara tim pengembang dan QA sangat penting untuk memvalidasi bahwa optimasi yang dilakukan tidak hanya meningkatkan performa tetapi juga menjaga stabilitas dan fungsionalitas aplikasi secara keseluruhan.
